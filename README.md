# Airing-Out
Worked with: SteveLoPorto

AI Project in which I programmed and designed various bots to plug a leak in a spacecraft using deterministic and probabilistic leak detectors.

The bots function as follows:
  Bot 1: Bot 1 begins by having taken a sense action in which it updates all cells around it in a (2k+1) by (2k+1) square to false in a boolean[][] detection square array that is being maintained in parallel with the ship. The detection square begins by having all cells in it as true (as possibly containing the leak), and once the bot is placed, the detection square gets updated to have the cells in an area around the bot marked as false. Then, Bot 1 proceeds to choose a path (utilizing BFS) to the nearest open true cell in the detection square, breaking ties at random. Once Bot 1 reaches the end of the path, it checks to see if it is in the cell containing the leak, and if it is, the number of actions taken by Bot 1 is printed and Bot 1 is done running. Otherwise, the bot updates the cell it is in to be false in the detection square and then calls updateDetectionSquare() to take another sense action. Bot 1 repeats the process of choosing a path and updating the detection square until it has found the cell containing the leak.
Bot 2: Bot 2 has very similar functionality to bot 1, but it will try to minimize the amount of overlapping detection squares. The bot starts in a function called run. The main knowledge base storage is represented as a 2d boolean array of squares that are either false, they were sensed and did not contain a leak, or true, they potentially have a leak in them, i.e. the detector square has not been run over them or the detection square has run over them and has found a leak in the radius. While the leak is not detected within the detection square it will do the following. First it will run findClosestPotentialleak(), a BFS algorithm to find the closest potential leak, which is a tile in my ship with a true value, this is nothing fancy, just plain old bfs. Then from there it will run the efficientSpot method to find a spot from the potential leak spot that will minimize the amount of false squares in the next detection square scan. It achieves this by first setting the bounds of the detection square, then it will run through for 4 separate loops. The first for loop will calculate the amount of the right half of the detection square that can be cut off, it does this by counting how many columns on the right side of the detection square have all false values. It then repeats this method of cut off for the left side. Then it will calculate the amount of cutoff for the top and bottom half of the square. It does the exact same way, but this time it will see how many rows have all false values within the detection square. After these loops run it will have the values of cuttoffLeft, cutoffRight, cuttoffUp, and cuttoffDown. It then runs find bestEfficentSpot on every pairing of horizontal cutoff and vertical cutoff to find the area on the ship that would maximize the gain from the cutoffs. This is because the ship might not have an open square on a spot that would maximize the cutoff values. The way this function works is it will run through the ship with an area of size cutoff vertical by cutoff horizontal adjacent to the bot, and if a square is open it will run bfs to see how far the path is from the bot because if the path is further than the cutoff values then we are not gaining any efficiency because the number of actions would be greater than just to run it the normal bot 1 way. If the path is further than the cutoff values it will not save it as a potential efficient spot. If it does find a potential spot it will save it and its cutoff values and update the best spot if a path uses more of the cutoff values. This function will run until it has found the spot that will maximize the movement of the cutoff values. Then the bot moves to the spot the function returns. It will then run update detection square at that spot, which is a function that will run though every square in the detection square radius. If there is no leak it sets all the values to false. If there is a leak it will set all the tiles within the detection square to turn, unless they were previously false and all the tiles outside the detection square to false. It will set the found leak global to true and enter a loop that will run the same code as above, but minus the efficient spot calculations, since the only true values are the size of the square this overlapping method would provide no increase in efficiency. So when this loop terminates the bot has found the leak.
Bot 3: Bot 3 begins by acquiring a list of moves which it must make to arrive at the cell with the highest probability of containing the leak. Bot 3 accomplishes said task by calling on the method findNextMoves(). The method findNextMoves() makes use of BFS, thereby breaking ties between cells that all have the highest probability of containing the leak by distance to the bot first, in order to find the shortest path to the cell that has the highest probability of containing the leak. In addition, in order to ensure that ties between cells that all have the highest probability of containing the leak are broken at random, findNextMoves() calls on the method randomNeighborToAdd(), which assists in adding the children of the current node to the fringe at random. Moreover, once Bot 3 receives its list of moves, it then moves one cell at a time and updates the probabilities of any non-leak cells along the way to be 0. Whenever Bot 3 updates the probability of a non-leak cell to be 0, it then calls on the method updateProbability() to adjust the remaining probabilities on the ship given that the leak was not in the cell the bot just moved to. Furthermore, if the bot comes across the cell that contains the leak on its way to the cell that has the highest probability of containing the leak, then the bot prints out the number of actions it took to reach the leak location and is done running. Otherwise, the bot calls on the method listenForBeep(). Finally, the method listenForBeep() updates the probabilities for all cells which may contain the leak based on whether or not the bot receives a beep. Bot 3 repeats the process of acquiring a list of moves, updating the probabilities, and listening for beeps until it has found the cell containing the leak.
Bot 4: Bot 4 begins by acquiring a list of moves which it must make to arrive at the cell with the highest probability of containing the leak. Bot 4 accomplishes said task by calling on the method findNextMoves(). The method findNextMoves() makes use of BFS, thereby breaking ties between cells that all have the highest probability of containing the leak by distance to the bot first, in order to find the shortest path to the cell that has the highest probability of containing the leak. In addition, in order to ensure that ties between cells that all have the highest probability of containing the leak are broken at random, findNextMoves() calls on the method randomNeighborToAdd(), which assists in adding the children of the current node to the fringe at random. Moreover, once Bot 4 receives its list of moves, it then moves one cell at a time and updates the probabilities of any non-leak cells along the way to be 0. Whenever Bot 4 updates the probability of a non-leak cell to be 0, it then calls on the method updateProbability() to adjust the remaining probabilities on the ship given that the leak was not in the cell the bot just moved to. Furthermore, if the bot comes across the cell that contains the leak on its way to the cell that has the highest probability of containing the leak, then the bot prints out the number of actions it took to reach the leak location and is done running. Otherwise, the bot calls on the method listenForBeep(). Finally, the method listenForBeep() updates the probabilities for all cells which may contain the leak based on whether or not the bot receives a beep. If the current square you are listening on has a probability above .5, the bot will listen 4 different times. This is to help the bot get the best possible result from the listen. Bot 4 repeats the process of acquiring a list of moves, updating the probabilities, and listening for beeps until it has found the cell containing the leak.
Bot 5: Bot 5 begins by having taken a sense action in which it updates all cells around it in a (2k+1) by (2k+1) square to false in a boolean[][] detection square array that is being maintained in parallel with the ship. The detection square begins by having all cells in it as true (as possibly containing the leak), and once the bot is placed, the detection square gets updated to have the cells in an area around the bot marked as false. Then, Bot 5 proceeds to choose a path to the nearest open true cell in the detection square, breaking ties at random. The method choosePath(), assists the bot in finding the path which it should follow to the nearest open true cell by finding the number of moves it takes the bot to get to a true cell from the cell above the bot’s location, below the bot’s location, to the left of the bot’s location, and to the right of the bot’s location. choosePath() finds the number of moves it takes the bot to get to a true cell by calling the method findClosestPotentialLeak() from each of the above described locations and storing the return values in an arrayList. The method findClosestPotentialLeak() runs BFS from the given location in search of a true cell in the detection square and then returns the number of moves necessary to reach that cell from the provided location, while also updating a stack of integers which contains all of the moves the bot needs to make to reach the nearest true cell from the provided location. Furthermore, once findClosestPotentialLeak() is done running on each of the open cells neighboring the bot, choosePath() then finds which of the discovered paths requires the least amount of moves to reach a true cell. If multiple paths require the same amount of moves, a random number is selected to determine the path chosen, thus breaking ties at random. The chosen path is then returned, which Bot 5 follows. Once Bot 5 reaches the end of the path, it checks to see if it is in the cell containing the leak, and if it is, the bot increases its count of the number of leaks found and plugs the leak, updating the cell of the former leak in the detection square to be false. If the bot has found two leaks, the number of actions taken by Bot 5 is printed and Bot 5 is done running. If the bot has not found two leaks, the bot calls updateDetectionSquare2Leaks() to take a sense action. The method updateDetectionSquare2Leaks() is a modified version of updateDetectionSquare() which Bot 1 makes use of. In this modified version, when a leak is detected, all cells outside of the detection square are only updated to be false if the bot has already found and plugged a leak. Otherwise, nothing is done to the cells outside of the detection square when a leak is detected. Bot 5 repeats the process of choosing a path and updating the detection square until it has found and plugged both leaks on the ship.
Bot 6: Bot 6 has very similar functionality to bot 5, but it will try to minimize the amount of overlapping detection squares. The bot starts in a function called run. The main knowledge base storage is represented as a 2d boolean array of squares that are either false, they were sensed and did not contain a leak, or true, they potentially have a leak in them, i.e. the detector square has not been run over them or the detection square has run over them and has found a leak in the radius. While the leak is not detected within the detection square it will do the following. First it will run findClosestPotentialleak(), a bfs algorithm to find the closest potential leak, which is a tile in my ship with a true value, this is nothing fancy, just plain old bfs. Then from there it will run the efficientSpot method to find a spot from the potential leak spot that will minimize the amount of false squares in the next detection square scan. It achieves this by first setting the bounds of the detection square, then it will run through for 4 separate loops. The first for loop will calculate the amount of the right half of the detection square that can be cut off, it does this by counting how many columns on the right side of the detection square have all false values. It then repeats this method of cut off for the left side. Then it will calculate the amount of cutoff for the top and bottom half of the square. It does the exact same way, but this time it will see how many rows have all false values within the detection square. After these loops run it will have the values of cuttoffLeft, cutoffRight, cuttoffUp, and cuttoffDown. It then runs find bestEfficentSpot on every pairing of horizontal cutoff and vertical cutoff to find the area on the ship that would maximize the gain from the cutoffs. This is because the ship might not have an open square on a spot that would maximize the cutoff values. The way this function works is it will run through the ship with an area of size cutoff vertical by cutoff horizontal adjacent to the bot, and if a square is open it will run bfs to see how far the path is from the bot because if the path is further than the cutoff values then we are not gaining any efficiency because the number of actions would be greater than just to run it the normal bot 1 way. If the path is further than the cutoff values it will not save it as a potential efficient spot. If it does find a potential spot it will save it and its cutoff values and update the best spot if a path uses more of the cutoff values. This function will run until it has found the spot that will maximize the movement of the cutoff values. Then the bot moves to the spot the function returns. It will then run update detection square at that spot, which is a function that will run though every square in the detection square radius. If there is no leak it sets all the values to false. If there is a leak it will set all the tiles within the detection square to turn, unless they were previously false and all the tiles outside the detection square to false. It will set the found leak global to true and enter a loop that will run the same code as above, but minus the efficient spot calculations, since the only true values are the size of the square this overlapping method would provide no increase in efficiency. So when this loop terminates the bot has found the leak. The bot functions the same as bot two, but now when the first leak is found it does not set the whole array to false. It will go into the leakFound loop with a copy of the ship that has all values outside the detection square as false. Then it will return to the main loop and run as though there is only one leak. 
Bot 7: Bot 7 begins by acquiring a list of moves which it must make to arrive at the cell with the highest probability of containing the leak. Bot 7 accomplishes said task by calling on the method findNextMoves(). The method findNextMoves() makes use of BFS, thereby breaking ties between cells that all have the highest probability of containing the leak by distance to the bot first, in order to find the shortest path to the cell that has the highest probability of containing the leak. In addition, in order to ensure that ties between cells that all have the highest probability of containing the leak are broken at random, findNextMoves() calls on the method randomNeighborToAdd(), which assists in adding the children of the current node to the fringe at random. Moreover, once Bot 7 receives its list of moves, it then moves one cell at a time and updates the probabilities of any non-leak cells along the way to be 0. Whenever Bot 7 updates the probability of a non-leak cell to be 0, it then calls on the method updateProbability() to adjust the remaining probabilities on the ship given that the leak was not in the cell the bot just moved to. Furthermore, if the bot comes across a cell that contains a leak on its way to the cell that has the highest probability of containing the leak, then the bot plugs the leak, sets the probability of the former leak cell to be 0, and calls updateProbabilities() to correct the remaining probabilities on the ship. In addition, the coordinates of the former leak cell are updated to be a non-existent cell in the ship, so that when Bot 7 calls the method listenForBeep2(), the method can determine whether Bot 7 can receive a beep from one leak or two leaks. Moreover, if the bot has found and plugged two leaks on the ship, then the bot prints the number of actions it took to find and plug both leaks, and the bot is done running. However, if the bot has not found two leaks once it's done making all of its moves, the bot calls the method listenForBeep2(). Finally, the method listenForBeep2() is a modified version of listenForBeep() which Bot 3 uses. In this modified version, the probabilities for all cells which may contain the leak are updated based on whether or not the bot receives a beep from either leak, as opposed to just one leak. Bot 7 repeats the process of acquiring a list of moves, updating the probabilities, and listening for beeps until it has found and plugged both leaks.
Bot 8: Bot 8 begins by acquiring a list of moves which it must make to arrive at the cell with the highest probability of containing the leak. Bot 8 accomplishes said task by calling on the method findNextMoves(). The method findNextMoves() makes use of BFS, thereby breaking ties between cells that all have the highest probability of containing the leak by distance to the bot first, in order to find the shortest path to the cell that has the highest probability of containing the leak. In addition, in order to ensure that ties between cells that all have the highest probability of containing the leak are broken at random, findNextMoves() calls on the method randomNeighborToAdd(), which assists in adding the children of the current node to the fringe at random. Moreover, once Bot 8 receives its list of moves, it then moves one cell at a time and updates the probabilities of any non-leak cells along the way to be 0. Whenever Bot 8 updates the probability of a non-leak cell to be 0, it then calls on the method updateProbability() to adjust the remaining probabilities on the ship given that the leak was not in the cell the bot just moved to. Furthermore, if the bot comes across a cell that contains a leak on its way to the cell that has the highest probability of containing the leak, then the bot plugs the leak, sets the probability of the former leak cell to be 0, and calls updateProbabilities() to correct the remaining probabilities on the ship. In addition, the coordinates of the former leak cell are updated to be a non-existent cell in the ship, so that when Bot 8 calls the method correctListenForBeep2(), the method can determine whether Bot 8 can receive a beep from one leak or two leaks. Moreover, if the bot has found and plugged two leaks on the ship, then the bot prints the number of actions it took to find and plug both leaks, and the bot is done running. However, if the bot has not found two leaks once it's done making all of its moves, the bot calls the method correctListenForBeep2(). Finally, the method correctListenForBeep2() is a modified version of listenForBeep2() which Bot 7 uses. In this modified version, the probabilities for all cells which may contain the leak are updated correctly based on the fact that there are now two leaks present in the ship. Bot 8 repeats the process of acquiring a list of moves, updating the probabilities, and listening for beeps until it has found and plugged both leaks.
Bot 9: Bot 9 begins by acquiring a list of moves which it must make to arrive at the cell with the highest probability of containing the leak. Bot 9 accomplishes said task by calling on the method findNextMoves(). The method findNextMoves() makes use of BFS, thereby breaking ties between cells that all have the highest probability of containing the leak by distance to the bot first, in order to find the shortest path to the cell that has the highest probability of containing the leak. In addition, in order to ensure that ties between cells that all have the highest probability of containing the leak are broken at random, findNextMoves() calls on the method randomNeighborToAdd(), which assists in adding the children of the current node to the fringe at random. Moreover, once Bot 9 receives its list of moves, it then moves one cell at a time and updates the probabilities of any non-leak cells along the way to be 0. Whenever Bot 9 updates the probability of a non-leak cell to be 0, it then calls on the method updateProbability() to adjust the remaining probabilities on the ship given that the leak was not in the cell the bot just moved to. Furthermore, if the bot comes across a cell that contains a leak on its way to the cell that has the highest probability of containing the leak, then the bot plugs the leak, sets the probability of the former leak cell to be 0, and calls updateProbabilities() to correct the remaining probabilities on the ship. In addition, the coordinates of the former leak cell are updated to be a non-existent cell in the ship, so that when Bot 9 calls the method correctListenForBeep2(), the method can determine whether Bot 9 can receive a beep from one leak or two leaks. Moreover, if the bot has found and plugged two leaks on the ship, then the bot prints the number of actions it took to find and plug both leaks, and the bot is done running. However, if the bot has not found two leaks once it's done making all of its moves, the bot calls the method correctListenForBeep2() three times. The reason Bot 9 calls correctListenForBeep() three times is to try to reduce the chance that Bot 9 is close to a leak, but does not hear a beep, causing it to potentially travel far away from the leak. Finally, the method correctListenForBeep2() is a modified version of listenForBeep2() which Bot 7 uses. In this modified version, the probabilities for all cells which may contain the leak are updated correctly based on the fact that there are now two leaks present in the ship. Bot 9 repeats the process of acquiring a list of moves, updating the probabilities, and listening for beeps until it has found and plugged both leaks.
